<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="test.js"></script>
</head>
<body>
<div style="margin: -7px">
    <div class="name">Бинарный поиск</div>
    <hr>
    <div class="block">
        <p>
            На прошлом уроке мы изучили сортировку слиянием. Сортировка пузырьком гораздо медленнее, поэтому нет смысла использовать ее в ваших программах.
        </p>
        <p>
            Однако, не всегда так просто выбрать нужный алгоритм. Иногда ускорить программу можно только при наличии у задачи определенных особенностей.
        </p>
        <p>
            Например, алгоритм поиска элемента в массиве работает за <b>O(n)</b>, но если массив отсортирован, то можно воспользоваться бинарным поиском, работающим за <b>O(log(n))</b>.
        </p>
        <div class="h">Бинарный поиск по массиву</div><hr>
        <p>
            Алгоритм достаточно прост и применяется в реальной жизни. Рассмотрим его на примере:<br>
            <div class="table">
                <b>a = [1, 3, 4, 6, 7, 8, 9, 11]</b><br><br>
            </div>
            Будем искать в этом массиве шестерку.<br>
            Посмотрим на элемент посередине. Он делит массив на две части (левую, где все элементы меньше) и правую (все элементы больше).
            <div class="table">
                <b>a = [1, 3, 4, 6, 7, 8, 9, 11]</b><br>
                <b>.................^...........</b><br><br>
            </div>
            Элемент посередине - семь, больше чем шесть. Значит все элементы справа нас больше не интересуют (так как они еще больше). Давайте заведем две переменные <b>l, r</b> показывающие текущие границы массива. Изначально <b>l = 0</b> (индекс первого элемента), <b>r = 8</b> (индекс после последнего элемента). Тогда элемент посередине имеет индекс <b>(l+r)/2</b>.
            <div class="table">
                <b>a = [1, 3, 4, 6, 7, 8, 9, 11]</b><br>
                <b>.....^..^..^..^..^..^..^..^..</b><br>
                <b>l = 0, r = 8</b><br><br>
            </div>
            Теперь, когда мы узнали, что правая половина нас не интересует, можно сместить правую границу на центр.
            <div class="table">
                <b>a = [1, 3, 4, 6, 7, 8, 9, 11]</b><br>
                <b>.....^..^..^..^..............</b><br>
                <b>l = 0, r = 4</b><br><br>
            </div>
            Опять посмотрим на элемент посередине - четыре, меньше чем шесть. Значит левая половина оставшегося массива нас не интересует и можно сдвинуть левую границу в центр. 
            <div class="table">
                <b>a = [1, 3, 4, 6, 7, 8, 9, 11]</b><br>
                <b>...........^..^..............</b><br>
                <b>l = 2, r = 4</b><br><br>
            </div>
            Центральный элемент - шесть. Мы нашли его всего за три операции (<b>log(8) = 3</b>). Давайте попробуем реализовать этот алгоритм.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>int</bl> l = <pu>0</pu>, r = n;<br>
                <bl>while</bl>(r - l &gt; <pu>1</pu>)<br>
                {<br>
                <t></t><gr>//...</gr><br>
              </code>
            </div>
        <p>
            Создаем две переменные, отвечающие за границы массива. Запускаем цикл, который будет повторять алгоритм (просмотр центрального элемента и отбрасывание половины массива) до тех пор, пока в границах массива не окажется один элемент. <b>l</b> будет равен его индексу, а <b>r</b> следующему.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>int</bl> m = (l + r) / <pu>2</pu>;<br>
              </code>
            </div>
        <p>
            Находим индекс центрального элемента.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>if</bl>(a[m] &lt; x)<br>
                {<br>
                <t></t>l = m;<br>
                }<br>
                <bl>else</bl><br>
                {<br>
                <t></t>r = m;<br>
                }<br>
              </code>
            </div>
        <p>
            Проверяем центральный элемент и сдвигаем границы. <b>x</b> - элемент, который мы ищем. Изучите полный код программы.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>int</bl> l = <pu>0</pu>, r = n;<br>
                <bl>while</bl>(r - l &gt; <pu>1</pu>)<br>
                {<br>
                <t></t><bl>int</bl> m = (l + r) / <pu>2</pu>;<br>
                <t></t><bl>if</bl>(a[m] &lt; x)<br>
                <t></t>{<br>
                <t></t><t></t>l = m;<br>
                <t></t>}<br>
                <t></t><bl>else</bl><br>
                <t></t>{<br>
                <t></t><t></t>r = m;<br>
                <t></t>}<br>
                }<br>
              </code>
            </div>
        <p>
            <b>a[l]</b> - искомый элемент.
        </p>
        <div class="h">Бинарный поиск по функции</div><hr>
        <p>
            Бинарный поиск можно применять не только для поиска элемента в массиве, но и для подбора ответа при решении задачи.
        </p>
        <p>
            Мы рассмотрим очень простой пример.<br>
            На создание одной единицы продукта фабрика тратит <b>n</b> рублей, а за продажу получает <b>m</b>. <b>m</b> больше, чем <b>n</b>. Сколько единиц продукта должна произвести фабрика, чтобы получить миллион рублей чистой прибыли (доходы минус расходы). Гарантируется, что требуется произвести не больше миллиарда единиц товара.
        </p>
        <p>
            Эту задачу можно легко решить и без применения бинарного поиска (решив линейное уравнение). Более сложные задачи будут приложены в конце этого урока, чтобы вы могли решить их самостоятельно.
        </p>
        <p>
            Напишем самое очевидное решение этой задачи - перебрать все возможные количества.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>int</bl> cnt = <pu>0</pu>;<br>
                <bl>while</bl>(m * cnt - n * cnt &lt; <pu>1000000</pu>)<br>
                {<br>
                <t></t>cnt++;<br>
                }<br>
                <gr>cout</gr> <re>&lt;&lt;</re> cnt;<br>
              </code>
            </div>
        <p>
            Такое решение работает за время <b>O(ans)</b>, где <b>ans</b> - ответ на задачу (может быть равен миллиарду).
        </p>
        <p>
            Можно заметить, что раз <b>m</b> больше, чем <b>n</b>, то чем больше товара мы произведем, тем больше прибыли получим. Давайте создадим две переменные <b>l</b> - минимальный возможный ответ на задачу (1 единица товара), и <b>r</b> - максимально возможный ответ (миллиард единиц).<br>
            Проверим, подойдет ли нам производство полмиллиарда единиц товара? Если прибыль будет больше, чем миллион рублей, то можно производить меньше. В противном случае, нужно произвести больше. Это же и есть описание бинпоиска!
        </p>
            <div class='code_block_b'>
            <code>
                <bl>int</bl> l = <pu>0</pu>, r = <pu>1000000000</pu>;<br>
                <bl>while</bl>(r - l &gt; <pu>1</pu>)<br>
                {<br>
                <t></t><bl>if</bl>(m * r - m * l &lt;= <pu>1000000</pu>)<br>
                <t></t>{<br>
                <t></t><t></t>l = m;<br>
                <t></t>}<br>
                <t></t><bl>else</bl><br>
                <t></t>{<br>
                <t></t><t></t>r = m;<br>
                <t></t>}<br>
                }<br>
                <gr>cout</gr> <re>&lt;&lt;</re> l;<br>
              </code>
            </div>
        <p>
            Этот код делает то же самое, что и предыдущий, но его сложность <b>O(log(ans))</b>
        </p>
        <div class="h">Вещественный бинарный поиск</div><hr>
        <p>
            До сих пор, мы могли использовать наш алгоритм только для поиска целого ответа на задачу. Но, никто не запрещает использовать и вещественный числа. Если в прошлой задаче разрешить производить нецелое количество единиц товара (например, заменить единицы на килограммы), то решение будет выглядить так.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>double</bl> l = <pu>0</pu>, r = <pu>1000000000</pu>;<br>
                <bl>while</bl>(r - l &gt; eps)<br>
                {<br>
                <t></t><bl>if</bl>(m * r - m * l &lt;= <pu>1000000</pu>)<br>
                <t></t>{<br>
                <t></t><t></t>l = m;<br>
                <t></t>}<br>
                <t></t><bl>else</bl><br>
                <t></t>{<br>
                <t></t><t></t>r = m;<br>
                <t></t>}<br>
                }<br>
                <gr>cout</gr> <re>&lt;&lt;</re> l;<br>
              </code>
            </div>
        <p>
            Переменая <b>eps</b> указывает на то, какая точнось требуется от ответа. Например, если вам нужен ответ с точностью до третьего знака, то можно задать ее так.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>double</bl> eps = <pu>0</pu>.<pu>001</pu>;<br>
              </code>
            </div>
        <p>
            Решите задачи на применение бинарного поиска.
            <div class="taskLink" onclick="goToTask()">Перейти к задачам</div>
        </p>
    </div>
</div>
</body>
</html>