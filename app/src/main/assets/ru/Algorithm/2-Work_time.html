<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="test.js"></script>
</head>
<body>
<div style="margin: -7px">
    <div class="name">Скорость программы</div>
    <hr>
    <div class="block">
        <p>
            Настоящий программист должен уметь не только писать программы, но и делать их быстрыми, эффективными. Базовые элементы программирования мы изучили в прошлом курсе, теперь настало время изучить алгоритмы (основные строительные блоки программ) и научиться писать быстрый код. Если вы не уверены в своих знаниях языка C++, то советуем выборочно прочитать статьи из прошлого курса, чтобы убрать пробелы в знаниях.
        </p>
        <div class="h">Быстрый код</div><hr>
        <p>
            Нельзя научиться писать эффективные программы, без умения оценить скорость кода.<br><br>
             Время, которое тратит программа, можно узнать запустив ее и подождав окончания ее работы. У этого подхода есть большой недостаток - узнать скорость программы вы сможете только после ее написания. На этом уроке мы узнаем способ узнать время работы программы, зная только ее алгоритм (представляя, как будет выглядеть будущий код).<br><br>
            Если данный материал покажется вам сложным, не пугайтесь и продолжайте изучение этого курса. После прочтения этой статьи у вас должно появиться лишь общее понимание того, как находить сложность алгоритма. Мы будем возвращаться и углубляться в эту тему в следующих статьях.
        </p>
        <p>
            Большинство задач в программировании можно решить различными способами. Почти всегда самым легким из них - это перебор всех возможных ответов на задачу и выбор среди них подходящего. Но, к сожалению, обычно этот способ еще и самый медленный. Чтобы понять, допустима ли для вас скорость текущего решения или же стоит начать придумывать более оптимальное перед написанием программы, нужно производить <b>асимптотический анализ</b>.
        </p>
        <p>
            <b>Сложность алгоритма</b> - функция, которая с точностью до константы определяет скорость роста времени работы программы в зависимости от увеличения входных данных.
        </p>
        <p>
            Это определение звучит сложно, а асимптотическому анализу посвящены целые учебники. Но для написания большинства программ достаточно руководствоваться лишь некоторыми простыми правилами.
        </p>
        <div class="h">"O" - нотация</div><hr>
        <p>
        </p>
            <div class='code_block_b'>
            <code>
                <bl>for</bl>(<bl>int</bl> i = <pu>0</pu>; i &lt; n; i++)<br>
                {<br>
                <t></t><gr>cout</gr> <re>&lt;&lt;</re> i <re>&lt;&lt;</re> <gr>"</gr> <gr>"</gr>;<br>
                }<br>
              </code>
            </div>
        <p>
            Правило 1. Посмотрим на простой цикл. Этот код повторяет операцию вывода на экран <b>n</b> раз. Считается, что все простые операции (не повторяющиеся в цикле или рекурсии) выполняются за единицу времени. Значит, код из примера выше выполнится за <b>n</b> единиц времени. Сложность этого алгоритма - <b>O(n)</b>. В скобках после буквы O записывается количество единиц времени, которое потратит код.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>for</bl>(<bl>int</bl> i = <pu>0</pu>; i &lt; n; i++)<br>
                {<br>
                <t></t><gr>cout</gr> <re>&lt;&lt;</re> i <re>&lt;&lt;</re> <gr>"</gr> <gr>"</gr>;<br>
                <t></t><gr>cout</gr> <re>&lt;&lt;</re> i * <pu>2</pu> <re>&lt;&lt;</re> <gr>"</gr> <gr>"</gr>;<br>
                }<br>
              </code>
            </div>
        <p>
            Правило 2. Сложность алгоритма считается с точностью до константы. Поэтому, как бы много одиночных операций не было внутри цикла, общее время их выполнения все равно <b>O(1)</b>, а общее время выполнения цикла - <b>O(n)</b>.<br>
            Если вам сложно понять это правило, то можно попробовать другой подход. Если внутри цикла, находится две операции, то общее время - <b>2*n</b>. Так как сложность алгоритма оценивается с точностью до константы, то все коэфициенты отбрасываются. Итоговая сложность - <b>O(n)</b>. При оценке сложности алгоритма могут использоваться только переменные.
        </p>
            <div class='code_block_b'>
            <code>
                <bl>for</bl>(<bl>int</bl> i = <pu>0</pu>; i &lt; n; i++)<br>
                {<br>
                <t></t><bl>for</bl>(<bl>int</bl> j = <pu>0</pu>; j &lt; m; j++)<br>
                <t></t>{<br>
                <t></t><t></t><gr>cout</gr> <re>&lt;&lt;</re> i <re>&lt;&lt;</re> <gr>"</gr> <gr>"</gr> <re>&lt;&lt;</re> j <re>&lt;&lt;</re> <gr>"</gr> <gr>"</gr>;<br>
                <t></t>}<br>
                <t></t><gr>cout</gr> <re>&lt;&lt;</re> <gr>endl</gr>;<br>
                }<br>
              </code>
            </div>
        <p>
            Правило 3. Если один цикл вложен в другой, то сложность такого алгоритма - произведение количества итераций обоих циклов. <b>O(n*m)</b>.<br> Время, затраченное вложенным циклом - <b>m</b>. Мы тратим это время <b>n</b> раз. Отсюда и появляется такое правило.
        </p>
        <p>
            Правило 4. При оценке сложности алгоритма, меньшие слагаемые не пишутся. Если время работы вашего алгоритма - <b>n<sup>2</sup> + n</b>, то итоговая сложность будет <b>O(n<sup>2</sup>)</b>. Это так, потому что <b>n<sup>2</sup></b> растет значительно быстрее при увеличении <b>n</b> и вносит гораздо больший вклад в итоговое время работы.
        </p>
        <p>
            Правило 5. Очень часто при оценке сложности алгоритма появляются двоичные логарифмы.<br><br>
            
            Логарифм числа <b>a</b> по основанию <b>b</b> - это такое число <b>c</b>, что <b>b<sup>c</sup> = a</b>. Например, логарифм восьми по основанию два равен трем, так как два в третьей степени равно восьми.<br><br>
            
            Двоичный логарифм - логарифм по основанию два.<br><br>

            Частый прием в программировании - разбивать исходную задачу на две половины, и решать их, а потом соединить ответ от обоих половин в ответ для всей задачи.<br><br>

            С математической точки зрения этот прием выглядит так:<br> Сколько раз нужно нацело разделить число <b>n</b> на 2, чтобы оно стало равно единице? Ответ: двоичный логарифм числа <b>n</b>.<br>

            Логарифм - очень медленно растущая функция. Двоичный логарифм от милиарда примерно равен тридцати! Поэтому, этот прием используется, чтобы ускорять программы. Вы также используете этот прием в своей жизни, даже если не знали об этом. Давайте рассмотрим следующий пример.
        </p>
        <p>
            Представьте, что вы пытаетсь найти слово в огромном словаре. Можно представлять себе словарь, как массив слов. Если мы хотим что-то найти в массиве, то пишем цикл, который проходит по всем его элементам и сравнивает - равен ли текущий элемент нужному или нет? Сложность такого алгоритма - <b>O(n)</b>.<br><br>

            Когда вы ищете информацию в словаре, вы не просматриваете все слова подряд, ведь это очень долго. Вы пользуетесь тем, что слова идут в алфавитном порядке.<br><br>
            
            Откроем словарь посередине и посмотрим на какое-нибудь слово. Если оно в алфавитном порядке находится позже, чем нужное, то вторая половина словаря нам уже точно не понадобится. Таким образом мы за одну операцию в два раза уменьшили количество слов в словаре. Будем повторять этот алгоритм до тех пор, пока не останется одно слово. Итоговая сложность - <b>O(log(n))</b>
        </p>
        <p>
            Это отличный пример того, как с помощью алгоритмов можно сильно уменьшить время работы программы. Если в вашем массиве будет миллион элементов, то обычный поиск потратит миллион единиц времени, а улучшенный - всего двадцать. Этот улучшенный алгоритм называется <b>бинарный поиск</b>. Мы подробнее разберем его на одном из следующих уроков. 
        </p>
        <p>
            Правило 6. Как это все использовать? Если у вас есть сложность алгоритма, то вы можете легко вычислить примерное время работы кода. Подставьте вместо всех переменных их значения и разделите результат на <b>10<sup>8</sup></b>. Вы получите примерное количество секунд, которые требуются программе. Если вас удовлетворяет этот результат, то можно приступать к реализации алгоритма. В противном случае, стоит подумать над более оптимальным решением.
        </p>
        <p>
            Пример. У вас есть алгоритм поиска людей в базе данных со сложностью <b>O(n<sup>2</sup>)</b>, где <b>n</b> - количество пользователей в базе. Вы ожидаете, что количество пользователей может достигать половины миллиона человек. Значит, максимальное время поиска - <b>500000 * 500000 / 100000000 ~ 2500 с</b>. Поиск человека будет выполняться примерно за 42 минуты.
        </p>
        <p>
            Для лучшего понимания материала изучите график, на котором представлена завимость времени работы программы от размера входных данных при разной сложности алгоритмов.
            <br><br><img src="img/asymp.png" style="width: 100%">
        </p>
        <div class="test">
            <div class="testTitle">Тест</div>
            <hr>
            <form onsubmit="checkForm(2); return false" name="testForm">
                <div class="test_stm">1. Какая сложность у этого алгоритма?</div><br>
                    <div class='code_block_b'>
                    <code>
                        <bl>for</bl>(<bl>int</bl> i = <pu>0</pu>; i &lt; n; i++)<br>
                        {<br>
                        <t></t><bl>for</bl>(<bl>int</bl> j = <pu>0</pu>; j &lt; m; j++)<br>
                        <t></t>{<br>
                        <t></t><t></t><gr>cout</gr> <re>&lt;&lt;</re> <pu>1</pu>;<br>
                        <t></t>}<br>
                        <t></t><bl>for</bl>(<bl>int</bl> j = <pu>0</pu>; j &lt; m; j++)<br>
                        <t></t>{<br>
                        <t></t><t></t><gr>cout</gr> <re>&lt;&lt;</re> <pu>1</pu>;<br>
                        <t></t>}<br>
                        }<br>
                        <bl>for</bl>(<bl>int</bl> j = <pu>0</pu>; j &lt; m; j++)<br>
                        {<br>
                        <t></t><gr>cout</gr> <re>&lt;&lt;</re> <pu>1</pu>;<br>
                        }<br>
                      </code>
                    </div>
                <div class="question" id="question0">
                    <span class="que0" onclick="c(0, 0)"><input type="radio" name="0" value="0"> <b>O(n)</b><br></span>
                    <span class="que0" onclick="c(0, 1)"><input type="radio" name="0" value="0"> <b>O(m)</b><br></span>
                    <span class="que0" onclick="c(0, 2)"><input type="radio" name="0" value="0"> <b>O(n + m)</b><br></span>
                    <span class="que0" onclick="c(0, 3)"><input type="radio" name="0" value="1"> <b>O(nm)</b><br></span>
                    <span class="que0" onclick="c(0, 4)"><input type="radio" name="0" value="0"> <b>O(2nm)</b><br></span>
                    <span class="que0" onclick="c(0, 5)"><input type="radio" name="0" value="0"> <b>O(n(m + m) + m)</b><br></span>
                </div>
                <br>
                <div class="test_stm">2. Какое максимальное <b>n</b> может обрабатывать алгоритм сложностью <b>O(n<sup>2</sup>log(n))</b>, чтобы укладываться в одну секунду?</div><br>
                <div class="question" id="question1">
                    <span class="que1" onclick="c(1, 0)"><input type="radio" name="1" value="0"> <b> n = 10<sup>2</sup></b><br></span>
                    <span class="que1" onclick="c(1, 1)"><input type="radio" name="1" value="1"> <b> n = 10<sup>3</sup></b><br></span>
                    <span class="que1" onclick="c(1, 2)"><input type="radio" name="1" value="0"> <b> n = 10<sup>5</sup></b><br></span>
                </div>
                <br>
                <div style="width: 100%; text-align: center">
                    <div class="testError hide" id="testError">Ответьте на все вопросы<br></div>
                    <div class="testResult hide" id="testResult"></div>
                    <input type="submit" value="Проверить" class="submit">
                </div>
            </form>
        </div>
    </div>
</div>
</body>
</html>